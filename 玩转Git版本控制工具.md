# 玩转Git版本控制工具

##### 1.安装git

官网：https://git-scm.com/

然后基本是就是一直下一步了。

安装完成后右键**Git bash here**可以打开git终端。

##### 2.初始化本地仓库

(1)创建一个文件夹，作为本地仓库

(2)设置签名[以供追责？]

```c
git config --global user.name "Happy-11"
git config --global user.email "1056972599@qq.com"
```

(3)初始化代码仓库

去文件夹目录右键打开**Git  bash here**就可以打开当前目录的终端，或使用cd命令一步一步过去（类似Liunx）

```c
//初始化当前目录为仓库
git init
```

就会自动生成一个.git文件夹，里面保存着配置文件

在命令行中：选中就是复制，右键就是粘贴

##### 3.将项目提交到暂存区，然后上传至本地库

先了解一个概念：

首先：你在做项目，没有操作任何git命令，所做的修改------工作区

然后：使用git add命令，提交  -------暂存区（缓存区）

最终：使用 git commit 命令提交  ------本地库

```c
git add demo.txt //将文件提交至暂存区 似乎只要提交文件一次到暂存区，以后就不用再提交了，移除后要再次add
git commit -m "我就是想上传这个文件" demo.txt   //将文件上传至本地库
git status //查看仓库文件状态（看看有谁没被管理）
```

注意事项：

（1）不放在本地仓库中【这是指GitRepository文件夹】的文件，git无法进行管理

（2）放在本地仓库目录下的文件，也不会自动管理，需要使用Add和Commit命令提交到本地库

（3）文件名区分大小写！

（4）空的文件夹status是不会追踪的，除非文件夹里有文件

（5）更新也是相同的操作。

##### 4.查看历史上传更新日志

```c
//查看日志
git log
//当前历史记录对应的索引 key
commit 092c96c9681e437c3223a7abb45f824acc169246
//上传的人的资料 value 
Author: Happy-11 <1056972599@qq.com>
//上传时间
Date:   Sun Dec 13 20:06:03 2020 +0800
//上传的注释
    上传的第二个文件

```

（1）越新的日志越往前。

（2）当历史日志过多的时候，左下角会出现【：】表示可以下一页，如果到尾页了，会显示【End】

​          下一页：空格

​          上一页：B

​          退出：Q

下面是更多的日志展示方式

```c
git log --pretty=oneline //完整一行展示日志  HEAD->master 指的是现在指针的位置
91390549d04eba2781554bb650e0b74e8205e793 (HEAD -> master) 修改了一次demo.txt
092c96c9681e437c3223a7abb45f824acc169246 上传的第二个文件
29ba483f0035ea16636ed08dd61d346dc39e4b6e 这是我第一次上传一个文件夹

git log --oneline //简洁的一行展现日志（把key减少到7个字符串）
9139054 (HEAD -> master) 修改了一次demo.txt
092c96c 上传的第二个文件
29ba483 这是我第一次上传一个文件夹
    
git reflog //简洁的一行展现日志（多了信息：HEAD@{数字}）含义：指针回到当前历史版本需要多少步
9139054 (HEAD -> master) HEAD@{0}: commit: 修改了一次demo.txt
092c96c HEAD@{1}: commit: 上传的第二个文件
29ba483 HEAD@{2}: commit (initial): 这是我第一次上传一个文件夹

    
```

##### 5.在各个版本中反复横跳

```c
//版本跳转
git reset --hard /*key值*/
$ git reset --hard 9139054
HEAD is now at 9139054 修改了一次demo.txt

git reset --mixed //本地库的指针移动的同时，重置暂存区，但是工作区不动
git reset --soft  //北地库的指针移动的同时，暂存去，工作区都不动
```

这样版本就会回退到指针所在的版本，用的最多的还是第一个参数的版本reset参数

##### 6.删除和找回本地库文件

```c
//删除文件 不能删除文件夹
rm /*文件名*///这里的删除不是真正删除，只是一个删除操作，要使用add和Commit命令提交到本地库后才算真正的删除
   
//执行以下操作才算真正的删除了文件（有日志记录） hard操作可以回滚到下面的任意一个时候
//删除工作区数据
rm demo2.txt
//同步到缓存区
git add demo2.txt
//同步到本地库
git commit -m "删除了demo2文件" demo2.txt
    
//找回本地库删除的文件  把指针回滚就可以了
$ git reset --hard 911b1fa

```

##### 7.比对文件修改了哪些内容（工作区和缓存区之间的差异）

```c
//比对文件 就是你修改了文件，但是没有提交，所以工作区和缓存区不一致，这时候就可以先进行比对
git diff /*文件夹名*/   //如果把文件提交了，则工作区和缓存区一致了 就不用比对了
//git 是按行为单位来管理数据  说是比对 更像是文件曾经被操作过的历史记录
git diff //不加文件名，会比对工作区和暂存区中所有文件的差异
git diff hard //暂存区和本地库进行比对
git diff /*key*/ /*文件名*/ //可以和日志中的任何一个历史版本比对文件
```

##### 8.关于分支

 	 我们一般开发项目，就是一条master主分支开发下去，但是如果想要开发一个新的功能，又不想影响主分支的开发进度，就可以开辟一个新的分支（会复制主分支，从当时复制的进度开始）进行开发，这个分支就可以随时更新，也不会影响主分支，如果觉得功能开发的好。就可以整合进主分支，开发的不好，就可以直接放弃这个分支。就不会影响到主分支的进度。

​     可以说主分支是这个项目共同的部分，可以利用这个主分支（基础分支）开发出不同的项目效果

```c
//关于分支的命令
git branch -v //查看所有分支最新的提交记录 前面带*的分支说明是你当前在的分支
git branch /*分支名*/  //创建新的分支 【从当前在的分支拷贝出来的】
     
$ git branch -v
Administrator@DESKTOP-A052CEG MINGW64 /d/Work/GitRepository (master) //这里也能看当前分支
*master 92f5273 “更新了test文件”
testBr 92f5273 “更新了test文件”  //会与之前你创建分支的时候所在的分支一模一样，从此时开始不一样
  
git checkout /*分支名*/  //切换分支 切换分支之前要先把做的操作提交完毕后才能切换
git merge /*分支名*/   //合并分支  你要先到要把其他分支合并的分支里（不能是在被合并的分支中）
//分支名旁边多了|mergeing  说明处于分支合并的状态中

```

​	在同一个文件的同一个位置修改，（合并的时候）则会出现冲突，这时候去查看文件，就会提示哪行的代码中分支不一致。
​	解决冲突的方式：去文件中删除多余的冲突符号，再删除不想要的那一行，留下想要的那一行
​	然后add文件进入缓存区，然后commit提交**【 这里的commit操作不能带文件名，否则会出错】**

（这些操作都是在mergeing下操作的） commit 无误以后，就不是mergeing状态了

##### 9.与GitHub远程库连接

1.首先登陆GitHub，创建一个仓库（如果已有请忽略）

2.查看所有远程库的地址，增加远程库

```c
git remote -v //查看所有保存的远程库的别名
git remote add /*远程库别名（自定义）*/ /*远程库的地址*/
//例    这一步需要GitHub账号密码
git remote add GitHubDemo https://github.com/GitHapyy11/GitRepoDemo.git

//这行指的是你可以从这个地址下载数据
GitHubDemo      https://github.com/GitHapyy11/GitRepoDemo.git (fetch)
//这行指的是你可以从这个地址推送数据
GitHubDemo      https://github.com/GitHapyy11/GitRepoDemo.git (push)
```

3.把本地库推送至远程库

```c
git push /*远程库别名*/ /*分支名*/
//例
git push GitHubDemo master
//新文件完整的一次push   就是先add  然后commit  最后push
```

​		**推送的时候需要账号密码**（这个账号必须是团队成员，可以通过项目创建者账号在GitHub仓库内进行邀请） 但由于同一台电脑会有账号缓存，所有这次推送是以管理员（项目创建者）的身份推送的。可以使用凭据管理器删除缓存。

​		推送完毕后在GitHub仓库就有显示了，这里推送的是master分支（其他分支也一样），但是GitHub默认的是main 分支，所以它会创建一个新的分支叫做master，里面就是你刚刚推送的分支。

4.把远程库克隆至本地库

```c
git clone /*远程库的地址*/
```

克隆操作可以帮我们完成

（1）初始化本地库

（2）将远程库内容完整的克隆到本地

（3）替我们创建远程库的别名

5.把远程库更新至本地库

```c
git fetch /*远程库别名*/ /*远程库上对应的分支*/  //抓取操作
git pull  /*远程库别名*/ /*远程库上对应的分支*/  //相当于fetch(下载分支)+merge (合并分支)  更新操作
```

​	抓取操作执行后，只是将远程库的内容下载到本地，但是工作区的文件并没有更新，工作区还是原先的内容。

这一步完成后，就可以使用git checkout命名切切换到他的分支内(需要在分支名前面加 **/远程库别名** )，查看文件

确认无误后在进行merge拉取合并(记得切换到自己的主分支去)

​	如果使用pull操作 就是上面抓取+合并操作的结合

6.更新远程库的时候发现冲突

​	如果你的上传的代码与远程库有冲突【同一个文件的同一列有不同的修改，一般是两个程序员同时上传，而没有及时更新的情况下回出现的问题，就是程序员在同一时间克隆更新分支，然后一方首先上传分支到远程库，这时候另一个程序员还没写完，但是本地库的代码已经与远程库不同步了，然后程序员把工作区的代码上传到本地库再上传到远程库，就会出现冲突】这时候就要先把远程库拉取下来，然后解决完冲突再上传到远程库。解决冲突的方式和本地分支冲突的方式一样。

##### 10.GitHub免密SSH登录

(1)生成SSH秘钥

```c
//进入用户的主目录（不一定是要主目录）
cd ~
//生成一个.ssh目录
ssh-keygen -t rsa -C /*项目所有者的邮箱*/ 
```

然后三次回车确认 就会生成SSH文件夹，路径在显示在git里面，可以看见（前缀带.隐藏的文件，需要操作才能看到，这里不做详细描述）

.SSH文件夹下会有两个文件 id_rsa      id_rsa.pub

打开id_rad.pub文件，将里面的内容进行复制操作

然后打开GitHub账号，打开设置，点击SSH and keys  添加一个SSHKeys

生成秘钥成功以后，就可以在仓库界面使用SSH秘钥了。

2.使用SSH秘钥

对SSH远程地址起一个别名

```c#
git remote add /*远程地址别名（自定义）*/ /*SSH远程地址（仓库中复制获得）*/
```

SSH好处：免密登录  不好的地方，只能针对一个账号

##### 11.实例操作：Unity同步

因为Unity并不是所有的文件都需要进行同步，所以可以建立一个文件来筛选需要的文件夹

```c
touch .gitignore //建立筛选用的文件 一般你在GitHub上建立仓库的时候会有，直接复制过来用就行 该文件在.git同一目录下
```

然后在本地git init 创建本地库

然后 **git add .**    把文件加入缓存

```c
//git常用命令
git --version  //查看版本
clear          //清屏
git config --global user.name "用户名"  //设置全局用户名
git config --global user.email "邮箱"  //设置全局邮箱
git init   //初始化当前目录为仓库
git add /*文件名(可以有多个，空格隔开）*/  //将文件提交至暂存区
git commit -m "这里写上传的注释" /*上传的文件名(可以有多个，空格隔开）*/  //将文件上传至本地库
git status //查看仓库文件状态（看看有谁没被管理）
git log //查看日志
git log --pretty=online //完整一行展示日志
git log --online        //简洁的一行展现日志（把key减少到7个字符串）
git reflog //简洁的一行展现日志（多了信息：HEAD@{数字}）含义：指针回到当前历史版本需要多少步
git reset --hard /*key值*/  //版本跳转
rm /*文件名*/ //这里的删除不是真正删除，要使用add和Commit命令提交到本地库后才算真正的删除(有日志记录)
git diff /*文件名*/ //比较工作区和暂存区文件的不同  不加文件名则比对全部文件
git diff hard //暂存区和本地库进行比对
git diff /*key*/ /*文件名*/ //可以和日志中的任何一个历史版本比对文件
git branch -v //查看所有分支最新的提交记录 前面带*的分支说明是你当前在的分支
git branch /*分支名*/  //创建新的分支 【从当前在的分支拷贝出来的】
git checkout /*分支名*/  //切换分支
git merge /*分支名*/   //合并分支
    
git remote -v //查看所有保存的远程库的别名
git remote add /*远程库别名（自定义）*/ /*远程库的地址*/  //增加一个远程库
git remote rm /*远程库别名（自定义）*/ 
 //删除一个远程库
git push /*远程库别名*/ /*分支名*/                     //将本地库推送至远程库
git clone /*远程库的地址*/                            //克隆远程库至本地库  
git pull  /*远程库别名*/ /*远程库上对应的分支*/  //相当于fetch(下载分支)+merge (合并分支)  更新操作
```

 



